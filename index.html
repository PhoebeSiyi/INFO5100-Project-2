<html>
<head>
	<title>Chicage Crime Distribution over Years</title>
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://d3js.org/topojson.v2.min.js"></script>
	<style>
		svg {
			display: block;
			margin: 0 auto;
		}

	</style>
</head>
<body>
	<svg id="map" width=800 height=530 style ="border: 1px solid black"}></svg>
	<!-- <div id="crime" style ="border: 1px solid black"></div> -->
	<div id="year"></div>
	<div id="information"></div>
	<script>
		const requestData = async () => {
			const streets = await d3.json("maps/streets.topojson");
			// console.log(streets);

			const wards = await d3.json("maps/wards.topojson");
			// console.log(wards);

			const street = topojson.feature(streets, streets.objects.shapes);
			const streetMesh = topojson.mesh(streets, streets.objects.shapes);
			const ward = topojson.feature(wards, wards.objects.shapes);
			const wardMesh = topojson.mesh(wards, wards.objects.shapes);

			// console.log(ward.features);

			let map = d3.select("svg#map");			
			let mapWidth = map.attr("width") * 0.8;
			let mapHeight = map.attr("height");
			let projection = d3.geoMercator().fitSize([mapWidth, mapHeight], ward);
			let path = d3.geoPath().projection(projection);

			// ward of chicage
			map.selectAll(".ward").data(ward.features)
				.enter()
				.append("path")
				.attr("id", d => d.properties["District_N"])
				.attr("class", "ward")
				.attr("fill", "lightgrey")
				.attr("d", path);

			map.append("path")
				.datum(wardMesh)
				.attr("class", "ward-outline")
				.style("fill", "lightgrey")
				.style("stroke", "grey")
				.attr("d", path);

			// streets
			map.selectAll(".area").data(street.features)
				.enter()
				.append("path")
				.attr("class", "street")
				.attr("fill", "lightgrey")
				.attr("stroke", "white")
				.attr("visibility", "hidden")// should be set to visible when map is zoomed
				.attr("d", path);


			// load the crime data
			const crime = await d3.csv("crime_2019.csv");
			console.log(crime);

			// get coordinates of center of wards
			var ward_info = {};
			for (let i = 0; i < ward.features.length; i++) {
				let current = ward.features[i];
				let coordinates = current.geometry.coordinates["0"];
				let longitudes = coordinates.map(d => d[0]);
				let latitudes = coordinates.map(d => d[1]);
				ward_info[i+1] = [[(d3.max(longitudes)+d3.min(longitudes))/2, (d3.max(latitudes)+d3.min(latitudes))/2], 0];
			}

			// // count number of crimes in each ward
			// crime.forEach( (d, i) => {
			// 	ward_info[d["Ward"]][1] += 1;
			// } );
			// // console.log(ward_info);

			// // draw circles, use the diameter of circles to represent number of crimes
			// let num = d3.values(ward_info).map(d => d[1]);
			// const circleScale = d3.scaleLinear()
			// 						.domain(d3.extent(num))
			// 						.range([5,13]);
			// for (let i = 0; i < d3.keys(ward_info).length; i++) {
			// 	let loc = projection(ward_info[i+1][0]);
			// 	map.append("circle")
			// 		.attr("r", circleScale(ward_info[i+1][1]))
			// 		.attr("cx", loc[0])
			// 		.attr("cy", loc[1])
			// 		.attr("class", "ward")
			// 		.attr("num", ward_info[i+1][1])// number of crimes happened in this ward
			// 		.attr("ward_N", i)// number of ward
			// 		.attr("visibility", "hidden")
			// 		.style("opacity", 0.8)
			// 		.style("fill", "red");
			// }

			// group current crime types into four main types
			let safety_ind = [ 'ASSAULT', 'NARCOTICS', 'OFFENSE INVOLVING CHILDREN', 'CRIM SEXUAL ASSAULT', 'SEX OFFENSE', 'HOMICIDE', 'STALKING', 'KIDNAPPING'];
			let property_ind = ['DECEPTIVE PRACTICE', 'THEFT', 'BURGLARY', 'BATTERY', 'ROBBERY', 'MOTOR VEHICLE THEFT', 'INTIMIDATION', 'GAMBLING'];
			let safety_soc = [ "CRIMINAL DAMAGE", 'WEAPONS VIOLATION', 'PUBLIC PEACE VIOLATION', 'CRIMINAL TRESPASS', 'INTERFERENCE WITH PUBLIC OFFICER', 'CONCEALED CARRY LICENSE VIOLATION', 'PROSTITUTION', 'HUMAN TRAFFICKING', 'OBSCENITY'];
			let others = [ 'NON-CRIMINAL', 'OTHER OFFENSE'];

			// map crime to different color
			crime_to_color = {"Personal Property": "steelblue", "Personal Safety": "darkorange", "Social Safety": "red", "Others": "green"};
			// use circle to represent crime, one for each, different type with different color
			map.selectAll("circle#small")	
				.data(crime)
				.enter()
				.append("circle")
				.attr("r", 1)
				.attr("cx", d => projection([d["Longitude"], d["Latitude"]])[0])
				.attr("cy", d => projection([d["Longitude"], d["Latitude"]])[1])
				.attr("class", "small")
				.attr("time", d => d["Date"])// happen date and time
				.attr("type", d => d["Primary Type"])// crime type
				.attr("description", d => d["Description"])// more detailed description
				.attr("arrest", d => d["Arrest"])
				.attr("domestic", d => d["Domestic"])
				.attr("ward_No", d => d["Ward"])// number of ward
				// .attr("visibility", "hidden")
				.style("opacity", 0.8)
				.style("fill", d => {
					if (property_ind.indexOf(d["Primary Type"]) != -1) {
						return crime_to_color["Personal Property"];
					}
					if (safety_ind.indexOf(d["Primary Type"]) != -1) {
						return crime_to_color["Personal Safety"];
					}
					if (safety_soc.indexOf(d["Primary Type"]) != -1) {
						return crime_to_color["Social Safety"];
					}
					return crime_to_color["Others"];
				});

			// append legend to select different type of crimes
			let legend = map.append("g")
							.attr("transform", "translate(" + map.attr("width")*0.8 + "," + map.attr("height")*0.2 + ")");
			legend.append("text")
					.text("Crime Type");

			d3.keys(crime_to_color).forEach( (d, i) => {
				legend.append("text")
					.text(d)
					.attr("x", 0)
					.attr("y", map.attr("height")*0.1*(i+1))
					.attr("class", "type")
					.style("fill", crime_to_color[d])
					.on("mouseover", function () {
						d3.selectAll("circle.small").each( function() {
							let circle = d3.select(this);
							let type = undefined;
							if (d == "Personal Property") {
								type = property_ind;
							}else if (d == "Personal Safety") {
								type = safety_ind;
							}else if (d == "Social Safety") {
								type = safety_soc;
							}else {
								type = others;
							};

							if (type.indexOf(circle.attr("type")) != -1) {
								circle.attr("r", 1)
										.style("opacity", 0.8);
							}else {
								circle.style("opacity", 0.1);
							};
						});
					});
			});

			// restore opacity when mouseout
			legend.on("mouseout", function() {
				d3.selectAll("circle.small")
					.attr("r", 1)
					.style("opacity", 0.8);
			})


		};
		requestData();
	</script>
</body>
</html>


